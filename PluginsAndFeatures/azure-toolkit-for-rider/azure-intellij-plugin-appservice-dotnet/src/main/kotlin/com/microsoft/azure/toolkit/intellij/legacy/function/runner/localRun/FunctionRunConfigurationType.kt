/*
 * Copyright 2018-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the MIT license.
 */

package com.microsoft.azure.toolkit.intellij.legacy.function.runner.localRun

import com.intellij.execution.RunManager
import com.intellij.execution.RunnerAndConfigurationSettings
import com.intellij.execution.configurations.ConfigurationTypeBase
import com.intellij.openapi.project.Project
import com.jetbrains.rd.util.lifetime.Lifetime
import com.jetbrains.rider.model.ProjectOutput
import com.jetbrains.rider.model.RunnableProject
import com.jetbrains.rider.model.RunnableProjectKind
import com.jetbrains.rider.run.AutoGeneratedRunConfigurationManager
import com.jetbrains.rider.run.configurations.IRunConfigurationWithDefault
import com.jetbrains.rider.run.configurations.IRunnableProjectConfigurationType
import com.jetbrains.rider.run.configurations.RunConfigurationHelper.hasConfigurationForNameAndTypeId
import com.jetbrains.rider.run.configurations.controls.LaunchProfile
import com.jetbrains.rider.run.configurations.launchSettings.LaunchSettingsJson
import com.jetbrains.rider.run.configurations.launchSettings.LaunchSettingsJsonService
import com.microsoft.azure.toolkit.ide.common.icon.AzureIcons
import com.microsoft.azure.toolkit.intellij.common.IntelliJAzureIcons
import com.microsoft.azure.toolkit.intellij.legacy.function.daemon.AzureRunnableProjectKinds
import com.microsoft.azure.toolkit.intellij.legacy.function.launchProfiles.getApplicationUrl
import com.microsoft.azure.toolkit.intellij.legacy.function.launchProfiles.getArguments
import com.microsoft.azure.toolkit.intellij.legacy.function.launchProfiles.getEnvironmentVariables
import com.microsoft.azure.toolkit.intellij.legacy.function.launchProfiles.getWorkingDirectory
import com.microsoft.azure.toolkit.intellij.legacy.function.localsettings.FunctionLocalSettings
import com.microsoft.azure.toolkit.intellij.legacy.function.localsettings.FunctionLocalSettingsService
import com.microsoft.azure.toolkit.intellij.legacy.utils.getProjectLaunchProfileByName

class FunctionRunConfigurationType : ConfigurationTypeBase(
    ID,
    "Azure - Run Function App",
    "Azure Run Function App configuration",
    IntelliJAzureIcons.getIcon(AzureIcons.FunctionApp.RUN)
), IRunnableProjectConfigurationType, IRunConfigurationWithDefault {
    companion object {
        const val ID = "AzureFunctionAppRun"
    }

    val factory = FunctionRunConfigurationFactory(this)

    init {
        addFactory(factory)
    }

    override fun isApplicable(kind: RunnableProjectKind) = kind == AzureRunnableProjectKinds.AzureFunctions

    override suspend fun tryCreateDefault(
        project: Project,
        lifetime: Lifetime,
        projects: List<RunnableProject>,
        autoGeneratedRunConfigurationManager: AutoGeneratedRunConfigurationManager,
        runManager: RunManager
    ): List<Pair<RunnableProject, RunnerAndConfigurationSettings>> {
        val functionProjects = projects.filter { it.kind == AzureRunnableProjectKinds.AzureFunctions }
        if (functionProjects.isEmpty()) return emptyList()

        val service = LaunchSettingsJsonService.getInstance(project)
        val result = mutableListOf<Pair<RunnableProject, RunnerAndConfigurationSettings>>()

        for (runnableProject in functionProjects) {
            val profiles = service.loadLaunchSettingsSuspend(runnableProject)?.profiles
            if (profiles != null) {
                generateConfigurationForProfiles(
                    profiles,
                    runnableProject,
                    runManager,
                    autoGeneratedRunConfigurationManager,
                    project
                ).forEach {
                    result.add(runnableProject to it)
                }
            } else {
                generateConfigurationForRunnableProject(
                    runnableProject,
                    runManager,
                    autoGeneratedRunConfigurationManager,
                    project
                )?.let {
                    result.add(runnableProject to it)
                }
            }
        }

        return result.toList()
    }

    private suspend fun generateConfigurationForProfiles(
        launchProfiles: Map<String, LaunchSettingsJson.Profile>,
        runnableProject: RunnableProject,
        runManager: RunManager,
        autoGeneratedRunConfigurationManager: AutoGeneratedRunConfigurationManager,
        project: Project
    ): List<RunnerAndConfigurationSettings> {
        val configurations = mutableListOf<RunnerAndConfigurationSettings>()

        for (profile in launchProfiles) {
            if (!profile.value.commandName.equals("Project", true))
                continue

            if (hasRunConfigurationEverBeenGenerated(
                    autoGeneratedRunConfigurationManager,
                    runnableProject.projectFilePath,
                    profile.key
                )
            ) continue

            val configurationName =
                if (runnableProject.name == profile.key) profile.key
                else "${runnableProject.name}: ${profile.key}"

            if (runManager.hasConfigurationForNameAndTypeId(configurationName, ID))
                continue

            val configuration = generateConfigurationForProfile(
                configurationName,
                runnableProject,
                profile.key,
                runManager,
                project
            )

            runManager.addConfiguration(configuration)
            markProjectAsAutoGenerated(
                autoGeneratedRunConfigurationManager,
                runnableProject.projectFilePath,
                profile.key
            )

            configurations.add(configuration)
        }

        return configurations
    }

    private suspend fun generateConfigurationForProfile(
        name: String,
        runnableProject: RunnableProject,
        profile: String,
        runManager: RunManager,
        project: Project
    ): RunnerAndConfigurationSettings {
        val settings = runManager.createConfiguration(name, factory)
        val projectOutput = runnableProject.projectOutputs.firstOrNull()
        val launchProfile = LaunchSettingsJsonService
            .getInstance(project)
            .getProjectLaunchProfileByName(runnableProject, profile)
        val localFunctionSettings = FunctionLocalSettingsService
            .getInstance(project)
            .getFunctionLocalSettings(runnableProject)
        (settings.configuration as? FunctionRunConfiguration)?.updateConfigurationParameters(
            runnableProject,
            projectOutput,
            launchProfile,
            localFunctionSettings
        )

        return settings
    }

    private fun generateConfigurationForRunnableProject(
        runnableProject: RunnableProject,
        runManager: RunManager,
        autoGeneratedRunConfigurationManager: AutoGeneratedRunConfigurationManager,
        project: Project
    ): RunnerAndConfigurationSettings? {
        if (hasRunConfigurationEverBeenGenerated(autoGeneratedRunConfigurationManager, runnableProject.projectFilePath))
            return null

        val configurationName = runnableProject.name
        if (runManager.hasConfigurationForNameAndTypeId(configurationName, ID))
            return null

        val settings = runManager.createConfiguration(configurationName, factory)
        val projectOutput = runnableProject.projectOutputs.firstOrNull()
        val localFunctionSettings = FunctionLocalSettingsService
            .getInstance(project)
            .getFunctionLocalSettings(runnableProject)
        (settings.configuration as? FunctionRunConfiguration)?.updateConfigurationParameters(
            runnableProject,
            projectOutput,
            null,
            localFunctionSettings
        )

        runManager.addConfiguration(settings)
        markProjectAsAutoGenerated(autoGeneratedRunConfigurationManager, runnableProject.projectFilePath)

        return settings
    }

    private fun FunctionRunConfiguration.updateConfigurationParameters(
        runnableProject: RunnableProject,
        projectOutput: ProjectOutput?,
        launchProfile: LaunchProfile?,
        localFunctionSettings: FunctionLocalSettings?
    ) = parameters.apply {
        projectFilePath = runnableProject.projectFilePath
        projectTfm = projectOutput?.tfm?.presentableName ?: ""
        profileName = launchProfile?.name ?: ""
        functionNames = ""
        trackArguments = true
        arguments = getArguments(launchProfile?.content, projectOutput)
        trackWorkingDirectory = true
        workingDirectory = getWorkingDirectory(launchProfile?.content, projectOutput)
        trackEnvs = true
        envs = getEnvironmentVariables(launchProfile?.content)
        useExternalConsole = false
        trackUrl = true
        startBrowserParameters.apply {
            url = getApplicationUrl(launchProfile?.content, projectOutput, localFunctionSettings)
            startAfterLaunch = launchProfile?.content?.launchBrowser == true
        }
    }

    private fun hasRunConfigurationEverBeenGenerated(
        autoGeneratedRunConfigurationManager: AutoGeneratedRunConfigurationManager,
        projectFilePath: String,
        profileName: String = "Default"
    ) = autoGeneratedRunConfigurationManager.hasRunConfigurationEverBeenGenerated(
        projectFilePath,
        mapOf(
            "azureFunctionProfileName" to profileName,
        )
    )

    private fun markProjectAsAutoGenerated(
        autoGeneratedRunConfigurationManager: AutoGeneratedRunConfigurationManager,
        projectFilePath: String,
        profileName: String = "Default"
    ) {
        autoGeneratedRunConfigurationManager.markProjectAsAutoGenerated(
            projectFilePath,
            mapOf(
                "azureFunctionProfileName" to profileName,
            )
        )
    }
}