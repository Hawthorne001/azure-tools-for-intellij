/*
 * Copyright 2018-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the MIT license.
 */

package com.microsoft.azure.toolkit.intellij.legacy.function.runner.localRun

import com.intellij.execution.RunManager
import com.intellij.execution.RunnerAndConfigurationSettings
import com.intellij.execution.configurations.ConfigurationTypeBase
import com.intellij.openapi.project.Project
import com.jetbrains.rd.util.lifetime.Lifetime
import com.jetbrains.rider.model.RunnableProject
import com.jetbrains.rider.model.RunnableProjectKind
import com.jetbrains.rider.run.AutoGeneratedRunConfigurationManager
import com.jetbrains.rider.run.configurations.IRunConfigurationWithDefault
import com.jetbrains.rider.run.configurations.IRunnableProjectConfigurationType
import com.jetbrains.rider.run.configurations.RunConfigurationHelper.hasConfigurationForNameAndTypeId
import com.jetbrains.rider.run.configurations.RunnableProjectKinds
import com.jetbrains.rider.run.configurations.launchSettings.LaunchSettingsJsonService
import com.microsoft.azure.toolkit.ide.common.icon.AzureIcons
import com.microsoft.azure.toolkit.intellij.common.IntelliJAzureIcons
import com.microsoft.azure.toolkit.intellij.legacy.function.daemon.AzureRunnableProjectKinds

class FunctionRunConfigurationType : ConfigurationTypeBase(
    "AzureFunctionAppRun",
    "Azure - Run Function App",
    "Azure Run Function App configuration",
    IntelliJAzureIcons.getIcon(AzureIcons.FunctionApp.RUN)
), IRunnableProjectConfigurationType, IRunConfigurationWithDefault {
    companion object {
        fun isTypeApplicable(kind: RunnableProjectKind) = kind == AzureRunnableProjectKinds.AzureFunctions
    }

    val factory = FunctionRunConfigurationFactory(this)

    init {
        addFactory(factory)
    }

    override fun isApplicable(kind: RunnableProjectKind) = isTypeApplicable(kind)

    override fun tryCreateDefault(
        project: Project,
        lifetime: Lifetime,
        projects: List<RunnableProject>,
        autoGeneratedRunConfigurationManager: AutoGeneratedRunConfigurationManager,
        runManager: RunManager
    ): List<Pair<RunnableProject, RunnerAndConfigurationSettings>> {
        val defaultSettingsList = mutableListOf<Pair<RunnableProject, RunnerAndConfigurationSettings>>()

        fun hasLaunchSettings(runnableProject: RunnableProject) =
            runnableProject.kind == RunnableProjectKinds.LaunchSettings &&
                    LaunchSettingsJsonService.getLaunchSettingsFileForProject(runnableProject)?.exists() == true

        fun alreadyGenerated(runnableProject: RunnableProject) =
            runManager.hasConfigurationForNameAndTypeId(runnableProject.name, this.id) &&
                    autoGeneratedRunConfigurationManager.hasRunConfigurationEverBeenGenerated(runnableProject.projectFilePath)

        val applicableProjects = projects.filter {
            isApplicable(it.kind) && !hasLaunchSettings(it) && !alreadyGenerated(it)
        }

        applicableProjects.forEach { applicableProject ->
            val defaultSettings = runManager.createConfiguration(applicableProject.name, factory)
            val configuration = defaultSettings.configuration as FunctionRunConfiguration
            configuration.parameters.projectFilePath = applicableProject.projectFilePath

            runManager.addConfiguration(defaultSettings)
            defaultSettingsList.add(applicableProject to defaultSettings)

            autoGeneratedRunConfigurationManager.markProjectAsAutoGenerated(applicableProject.projectFilePath)
        }

        return defaultSettingsList.toList()
    }
}